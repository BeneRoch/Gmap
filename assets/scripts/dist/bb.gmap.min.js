/**
 * @name Bene Bundle (BB)
 * @version version 1.0
 * @author Bene Roch
 * @description
 * DATAS
 * All datas added to the object will be affected to a "data object"
 * which makes all affectation pass by a single entry point
 */

var BB = BB || {};

/**
* BB.data Class
* This class exists to decide wheiter or not you wanna
* show the data, make them accessible to the public
*
*/
BB.data = function(data)
{

	this.__PROTECTED__     = [];
	this.__HIDDEN_DATA__   = true;


	if (this.__HIDDEN_DATA__) {
		var __DATA = data || {};
		return {
			set_data: function(data) 
			{ 	
				for (var key in data) {
					__DATA[key] = data[ key ];
				}
		 	},
			get_data: function(data) 
			{ 
				if (!data) {
					return __DATA; 
				}
				if (typeof __DATA[ data ] != 'undefined') {
					return __DATA[ data ];
				}
				return '';
			},
			remove_data: function(key)
			{
				if (!key) {
					__DATA = {};
				}

				if (typeof __DATA[ key ] != 'undefined') {
					__DATA[ key ] = undefined;
					delete __DATA[ key ];
				}
				return ;
			}
		}
	}

	this.__DATA = data || {};

	this.set_data = function(data) 
	{ 
		if (!this.__DATA) {
			this.__DATA = data || {};
			return ;
		}	
		if (!data) {
			return ;
		}
		for (var key in data) {
			this.__DATA[key] = data[ key ];
		}
		return ;
	}

	this.get_data = function(data) 
	{ 
		if (!data) {
			return this.__DATA; 
		}
		if (typeof this.__DATA[ data ] != 'undefined') {
			return this.__DATA[ data ];
		}
		return ;
	}

	this.remove_data = function(key)
	{
		if (!key) {
			this.__DATA = {};
		}

		if (typeof this.__DATA[ key ] != 'undefined') {
			this.__DATA[ key ] = undefined;
			delete this.__DATA[ key ];
		}
		return ;
	}

	return this;
}

/**
 * @name Bene Bundle (BB)
 * @version version 1.0
 * @author Bene Roch
 * @description
 * BASE
 * All reusable object methods and properties
 * - set_data
 * - data
 * - remove_data
 * - sanitize
 * - unsanitize
 * - escape_data
 * - unescape_data
 * - ident
 * - set_ident
 * - error // using the this.__BB_DEBUG__ to output error
 * Development feature.
 */

var BB = BB || {};

/**
* BB.base Class
* Base of all BB's objects
*
*/
BB.base = function()
{

	this.__BB_DEBUG__	 = false;
	this.__PROTECTED__   = [];

	this._data = new BB.data();
};

/**
*
* @param data 	|	{Object}	|	{ key : data, key : data } object
* @return this (chainable)
*/
BB.base.prototype.set_data = function(data)
{
	if (typeof data != 'object') {
		return this;
	}

	this._data.set_data(data);
	return this;

};

/**
*
* @param data 	|	{Object}	|	{ key : data, key : data } object
* @return this (chainable)
*/
BB.base.prototype.remove_data = function(data)
{
	this._data.remove_data(data);
	return this;

};

/**
* 
* @return {mixed} data | {Object} data  || {Mixed} data[ key ]
*/
BB.base.prototype.get_data = function(key)
{
	var data = this.data();
	if (typeof data[ key ] != 'undefined') {
		return data[ key ];
	}
	return {};
};

/**
*
* @param data 	|	{Object}	|	{ key : data, key : data } object
* @return this (chainable)
*/
BB.base.prototype.data = function(data)
{
	return this._data.get_data(data);
};

BB.base.prototype.sanitize = function()
{
	var data = this.data();
	data = this._escape_data(data);
	this.set_data(data);
	return this;
};

/**
* Every data passed to this function will be cleaned and encoded for web
* Recursive
* Prevents output errors
* @param data 		|		{Object} 		|
* @return {Object} data
*/ 
BB.base.prototype._escape_data = function(data) {
	var that = this;

	if (typeof data == 'undefined') {
		return '';
	}

	if (typeof data == 'object' && data.length) {
		var i = 0;
		var count = data.length;
		for (; i < count; i++) {
			data[i] = this._escape_data(data[i]);
		}
	}

	if (typeof data == 'object') {
		for (var k in data) {
			data[k] = this._escape_data(data[k]);
		}
	}

	if (typeof data == 'string') {
		return escape( data );
	}

	// Default;
	return data;
};

/**
* Every data passed to this function will be cleaned and encoded for web
* Recursive
* Prevents output errors
* @param data 		|		{Object} 		|
* @return {Object} data
*/ 
BB.base.prototype._unescape_data = function(data) {
	var that = this;

	if (typeof data == 'undefined') {
		return '';
	}

	if (typeof data == 'array') {
		var i = 0;
		var count = data.length;
		for (; i < count; i++) {
			data[i] = this._unescape_data(data[i]);
		}
	}

	if (typeof data == 'object') {
		for (var k in data) {
			data[k] = this._unescape_data(data[k]);
		}
	}

	if (typeof data == 'string') {
		return unescape( data );
	}

	// Default;
	return data;
};



/**
* Return current object ident
* Ident
* @return string
*/
BB.base.prototype.ident = function()
{
	var _data = this.data();
	if (typeof _data.ident != 'string') {
		this.error('Ident is not a String which is odd. ' + _data.ident);
		return '';
	}
	return _data.ident;
};

/**
* Sets the ident for the current object
* Ident parameters must be a string. If its not, it is converted
* to one, which my give {Object object} if object values are passed.
* If __BB_DEBUG__ is on, throws an error
*
* @param string 	ident 			MUST be a string
* @return this (chainable)
*/
BB.base.prototype.set_ident = function( ident )
{
	if (typeof ident != 'string') {
		ident = ''+ident;
		this.error('Ident must be a string. Automatically converted to : ' + ident);
	}
	this.set_data({ 'ident': ident });

	return this;
};


BB.base.prototype.error = function( error_msg )
{
	if (this.__BB_DEBUG__) {
		throw Error( error_msg );
	}
	return this;
};


BB.base.prototype.is_empty_object = function( obj )
{
	for(var prop in obj) {
		if(obj.hasOwnProperty(prop)) {
			return false;
		}
	}

	return true;
}
/**
 * @name BB Gmap controller
 * @version version 1.0
 * @author Bene Roch
 * @description
 * MAP Controller
 * Controller for a google map object
 * This makes it possible to track all whats going on
 * with the google map
 */

/**
* EAMPLE DATAS
*
	var map = new BB.gmap.controller(document.getElementById('test'), {
	   map: {
	   center: {
					x 	: 45.577997,
					y 	: -73.76850009999998
				},
				zoom: 15,
				mapType 	: 'roadmap',
				coordsType	: 'inpage', // array, json? (vs ul li)
				map_mode	: 'default'
		},
		places :{
			test : {
				type : 'marker',
	            icon : 'http://2.bp.blogspot.com/_--4sDAhQ5LI/TOquH6OPLWI/AAAAAAAACeM/JvG-MItGlmk/s1600/CRM5FormScripting4.png',
				coords : [ 45.577997,-73.76850009999998 ]
			}
		}
	})
	map.init()

	map.add_place_by_address('test_un_autre', '1859 iberville, montrÃ©al, qc, h2k3c4', {
		type : 'marker',
	    icon : 'http://localhost/test/assets/images/marker.png'
	})
*/
var BB = BB || {};

BB.gmap = BB.gmap || {};
/**
* This is the gmap object
*/
BB.gmap.controller = function(container, data)
{
	this._MAP;
	this._CONTAINER = container;

	this._MARKERS = {};
	this.__PLACES = {
		markers : {},
		polygons 	: {},
		lines 	: {}
	};

	this.set_data(data);

	return this;
}

BB.gmap.controller.prototype = new BB.base();

/**
* Return associated map
*/
BB.gmap.controller.prototype.map = function()
{
	if (!this._MAP) {
		// No map yet
		this.error('No map associated to the current controller')
		return;
	}
	return this._MAP;
}

/**
* Helper
* Kind of does same thing but on the map object
* You can always object.map().[methods]()
* @see https://developers.google.com/maps/documentation/javascript/reference#Map
*/
BB.gmap.controller.prototype.set_zoom = function(zoom)
{
	this.map().setZoom( zoom );
}

/**
* MAP OPTIONS
* Map options will be passed AS IS to the map object
* Only the center position will be translated into google object
* center :
* {
*	x : float
*	y : float
* }
* @see https://developers.google.com/maps/documentation/javascript/reference#MapOptions
*/
BB.gmap.controller.prototype.init = function()
{
	var _data = this.data();

	// Map options
	var map_options = this.data('map');

	// Converts center position into google objects
	map_options.center = new google.maps.LatLng(parseFloat(map_options.center.x), parseFloat(map_options.center.y));

	// Affect new map object
	this._MAP = new google.maps.Map(this._CONTAINER, map_options);

	// Any places yet?
	if (typeof _data[ 'places' ] == 'undefined') {
		this.error('You haven\'t set any places yet')
		return this;
	}
	this.add_places( _data[ 'places' ] )
	return this;
}

BB.gmap.controller.prototype.set_styles = function ( styles ) {
	if (typeof styles != 'object') {
		this.error('Invalid type styles in BB.gmap.set_styles()' + styles)
	}

	// Create a new StyledMapType object, passing it the array of styles,
	// as well as the name to be displayed on the map type control.
	var styles = new google.maps.StyledMapType(styles,
	{name: "Custom"});

	//Associate the styled map with the MapTypeId and set it to display.
	this.map().mapTypes.set('custom', styles);
	this.map().setMapTypeId('custom');
	return this;
}


/**
* places :
* {
*	ident : { data },
*	ident : { data }
* }
*
*/
BB.gmap.controller.prototype.add_places = function( places ) 
{
	if (!places) {
		this.error('Invalid places specified :' + places)
		return this;
	}

	for (var p in places) {
		this.add_place( p, places[ p ] );
	}

	return this;
}

BB.gmap.controller.prototype.set_place = function( type, ident, data )
{
	if (!ident || !data) {
		this.error('Missing parameters in BB.gmap.controller.set_place( '+type+', '+ident+', '+data+')');
		return this;
	}
	if (typeof this.__PLACES[ type ] == 'undefined') {
		this.error('Invalid data type at BB.gmap.controlle.set_place( '+type+', '+ident+', '+data+')');
		return this;
	}
	if (typeof this.__PLACES[ type ][ ident ] == 'undefined') {
		this.__PLACES[ type ][ ident ] = {};
	}
	this.__PLACES[ type ][ ident ] = data;
	return this;
}

/**
* {
*	ident : { data }
* }
*
*/
BB.gmap.controller.prototype.add_place = function( ident, data )
{
	if (!data) {
		this.error('Missing parameter BB.gmap.controller.prototype.add_place ( ident, data ) : ( ' + ident + ', ' + data + ' )');
		return this;
	}

	// Every place should have is uniq ident
	if (typeof data[ 'type' ] != 'string') {
		this.error('Missing parameter "type" in BB.gmap.controller.prototype.add_place');
		return this;
	}

	// Set ident.
	data[ 'ident' ] = ident;

	var type = data['type'];

	switch (type) {
		case 'marker':
			this.set_place('markers', ident, new BB.gmap.marker(data, this));
			// Might add some extra sanitize functions here
			// this.set_place('markers', ident, data)

		break;

		case 'line' :
			this.set_place('lines', ident, new BB.gmap.line(data, this));
			// this.add_line( ident, data );
			// this.set_place('lines', ident, data)
		break;

		case 'polygon':
			this.set_place('polygons', ident, new BB.gmap.polygon(data, this));
			// this.add_polygon( ident, data );
			// this.set_place('polygons', ident, data)
		break;
	}

	return this;
}

BB.gmap.controller.prototype.get_places = function()
{
	return this.__PLACES;
}
BB.gmap.controller.prototype.get_places_by_type = function(type)
{
	return this.__PLACES[ type ];
}

/**
*
*
*/
BB.gmap.controller.prototype.add_marker = function( ident, data )
{
	this.set_place('markers', ident, new BB.gmap.marker(data, this));
	this.get_places_by_type('markers')[ ident ].set_ident('ident');
	return this;
}

/**
*
* @return {mixed} BB.gmap.marker || false
*/
BB.gmap.controller.prototype.get_marker = function( ident )
{
	var _markers = this.get_places_by_type('markers');

	if (typeof _markers[ ident ] == 'undefined') {
		this.error('Invalid marker ident at BB.gmap.controller.get_marker( ident ) : ' + ident)
		return false;
	}
	return _markers[ ident ];
}

BB.gmap.controller.prototype.add_place_by_address = function( ident, address, data ) 
{
	var that = this;
	this.geocode_address( address, function(coords) {
		data.coords = coords;
		that.add_place(ident, data);
	})
}


BB.gmap.controller.prototype.geocode_address = function( address, callback ) 
{
	var ret = Array();

	if (typeof google != 'undefined') {

		var geocoder = new google.maps.Geocoder();

		geocoder.geocode({ 
			'address': address 
		}, 
		function(results, status) {

		  if (status == google.maps.GeocoderStatus.OK) {
			var lat = results[0].geometry.location.lat();
			var lon = results[0].geometry.location.lng();
			
			if (typeof callback == 'function') {
				callback( [lat, lon ] );
			}

		  }
		  return ret;

		});

	} else {

		return error;

	}
}

/**
*
* @return {mixed} BB.gmap.marker || false
*/
BB.gmap.controller.prototype.get_place = function( ident )
{
	var places = this.get_places();
	var place = false;

	for (var k in places)
	{
		var places_by_type = this.get_places_by_type( k );
		if (!this.is_empty_object( places_by_type )) {
			place = typeof places_by_type[ ident ] == 'object' ? places_by_type[ ident ] : false;
		}
	}

	if (!place) {
		this.error('Invalid ident at BB.gmap.controller.get_place( ident ) : ' + ident);
		return false;
	}

	return place;
}




BB.gmap.controller.prototype.add_clusterer = function()
{

}
BB.gmap.controller.prototype.get_clusterer = function()
{

}

BB.gmap.controller.prototype.filter = function( filters ) 
{

}

BB.gmap.controller.prototype.clear_infoboxes = function()
{

}

BB.gmap.controller.prototype.refresh = function()
{
	this.clear_infoboxes();

}

/**
* Utils
* @param Array [ lat, lon ]
*/
BB.gmap.controller.prototype.translate_coords = function(coords) {
	if (typeof coords != 'object') {
		return ;
	}

	var total = coords.length;
	if (total != 2) {
		return ;
	}
	return new google.maps.LatLng(coords[0], coords[1]);
}

/**
 * @name BB Gmap controller
 * @version version 1.0
 * @author Bene Roch
 * @description
 * MAP Controller
 * Controller for a google map object
 * This makes it possible to track all whats going on
 * with the google map
 */

var BB = BB || {};

BB.gmap = BB.gmap || {};

/**
* #Marker object class
* Accepts all datas at first 
* Needs a google.maps.Marker() object ( data[ 'marker' ] ) in order
* be functionnal with all methods
*
* ##Options ( options {} )
* - `icon`:
* 	- image `url`
* 
* 
* ##Methods
*
*
*/
BB.gmap.marker = function( data, controller )
{
	// Contains the google map object
	this.__MARKER = undefined;
	this.__MEDIA;
	this.__CONTROLLER = controller;

	// Status vars
	this._image_loaded = false;
	this._marker_loaded = false;

	// Set data
	this.set_data( data );

	// If case sanitize is needed in the "set_data" process,
	// retrive them with data()
	var _data = this.data();

	this.init();
	// Chainable
	return this;
}

BB.gmap.marker.prototype = new BB.base();

BB.gmap.marker.prototype.init = function()
{
	var _data = this.data();
	
	if (typeof _data['icon'] == 'string') {
		this.set_image( _data.icon );
	}

	this.__ICON;

	return this;
}

BB.gmap.marker.prototype.icon = function()
{
	if (!this.__ICON) {
		this.error('No icon were defined yet.')
		return new Image();
	}
	return this.__ICON;
}


BB.gmap.marker.prototype.set_icon = function( icon )
{
	if (typeof icon != 'object') {
		this.error('Invalid icon at BB.gmap.marker.prototype.set_icon( ' + icon + ' )');
		return this;
	}
	this.__ICON = icon;

	return this;
}




BB.gmap.marker.prototype.set_image = function( src )
{
	var img = new Image();

	img.data = this;

	img.onload = function()
	{
		this.data.set_icon( this );
		this.data.display();
	}
	img.src = src;

	return this;
}

BB.gmap.marker.prototype.display = function()
{
	// if ()
	var width = this.icon().width;
	var height = this.icon().height;

	var _data = this.data();

	if (typeof _data.coords != 'object') {
		this.error('Requires coordinates [lat, lng] at BB.gmap.marker.display()');
		return false;
	}
	var options = {
		map: this.controller().map(),
		icon: new google.maps.MarkerImage(
			// image src
			this.icon().src,
			// Width, Height.
			new google.maps.Size(width, height),
			// Origin for this image; X, Y.
			new google.maps.Point(0, 0),
			// Anchor for this image; X, Y.
			new google.maps.Point(width, height),
			new google.maps.Size(width, height)
	   	),
	   	position: new google.maps.LatLng(_data.coords[0], _data.coords[1]),
	   	optimized: false
	}

	if (typeof this.marker() != 'undefined') {
		this.marker().setOptions(options);
	} else {
		var marker = new google.maps.Marker(options);
		this.set_marker( marker );
	}

	return this;
}

BB.gmap.marker.prototype.show = function()
{
	var _marker = this.marker();
	if (typeof marker == 'undefined') {
		this.error('No marker defined at BB.gmap.marker.show()')
	}
	marker.setMap(this.controller().map());
}

BB.gmap.marker.prototype.hide = function()
{
	var _marker = this.marker();
	if (typeof marker == 'undefined') {
		this.error('No marker defined at BB.gmap.marker.hide()')
	}
	_marker.setMap(null);
}


BB.gmap.marker.prototype.controller = function()
{
	return this.__CONTROLLER;
}


/**
* Require google marker object
* @return this (chainable)
*/
BB.gmap.marker.prototype.set_marker = function( marker )
{
	if (this._marker_loaded) {
		// Error
		this.error( 'There is already a marker affected to this instanciation of a [BB.gmap.marker] ( ' + this.ident() + ' )' );
		return this;
	}
	this._marker_loaded = true;

	this.__MARKER = marker;
	return this;
}

/**
* Return google marker object
* @return google.maps.Marker()
*/
BB.gmap.marker.prototype.marker = function()
{
	return this.__MARKER;
}

BB.gmap.marker.prototype.refresh = function()
{
	var opts = this.data('_opts');
	var marker = this.marker();
	marker.setOptions(opts);
}

/**
* Requires either google map object
*
*/
BB.gmap.marker.prototype.set_map = function( map )
{
	this.marker().setMap( map );

	return this;
}

/**
 * @name BB Gmap Line
 * @version version 1.0
 * @author Bene Roch
 * @description
 * Map LINE
 * 
 */

var BB = BB || {};

BB.gmap = BB.gmap || {};

/**
* #Marker object class
* Accepts all datas at first 
* Needs a google.maps.Marker() object ( data[ 'line' ] ) in order
* be functionnal with all methods
*
* ##Options ( options {} )
* - `icon`:
* 	- image `url`
* 
* 
* ##Methods
*
*
*/
BB.gmap.line = function( data, controller )
{
	// Contains the google map object
	this.__OBJECT = undefined;
	this.__STYLES;
	this.__PATHS;
	this.__CONTROLLER = controller;

	// Set data
	this.set_data( data );

	// If case sanitize is needed in the "set_data" process,
	// retrive them with data()
	var _data = this.data();

	this.init();
	// Chainable
	return this;
}

BB.gmap.line.prototype = new BB.base();

BB.gmap.line.prototype.init = function()
{
	var _data = this.data();
	
	if (typeof _data[ 'styles' ] == 'object') {
		this.add_styles( _data[ 'styles' ]);
	}

	if (typeof _data[ 'paths' ] == 'object') {
		this.set_paths( _data[ 'paths' ]);
	}

	if (this.get_paths() && this.get_styles()) {
		this.display();
	}

	return this;
}

/**
* Getter & setters
*/

BB.gmap.line.prototype.add_styles = function( styles )
{
	// Add validation here.

	this.__STYLES = styles;
}

/**
* AUTOMATICALLY SETS THE STYLE
*/
BB.gmap.line.prototype.set_styles = function( styles )
{
	this.add_styles(styles);
	this.display();
	return this;
}

BB.gmap.line.prototype.get_styles = function() 
{
	return this.__STYLES;
}


BB.gmap.line.prototype.set_paths = function( paths )
{
	if (typeof paths != 'object') {
		this.error('Invalid paths at BB.gmap.line.set_paths :'+paths);
		return ;
	}

	if (!(paths[0] instanceof google.maps.LatLng)) {
		var i = 0;
		var count = paths.length;
		var coords = [];
		for (; i<count; i++) {
			if (typeof paths[i] != 'object') {
				// Error.
				break;
			}
			var push = this.controller().translate_coords(paths[i]);

			coords.push( push );
		}

		paths = coords;
	}

	this.__PATHS = paths;
}

BB.gmap.line.prototype.get_paths = function()
{

	return this.__PATHS;
}


BB.gmap.line.prototype.display = function()
{
	var _data = this.data();

	var styles = this.get_styles();
	if (typeof styles == 'undefined') {
		this.error('Undefined styles at BB.gmap.line.display : ' + styles)
	}

	var paths = this.get_paths();
	if (typeof paths == 'undefined') {
		this.error('Undefined paths at BB.gmap.line.display : ' + paths);
	}

	styles.path = paths;

	if (typeof this.object() != 'undefined') {
		this.object().setOptions(styles);
	} else {
		var line = new google.maps.Polyline(styles);
		this.set_object( line );
	}

	this.set_map(this.controller().map());

	return this;
}

BB.gmap.line.prototype.show = function()
{
	var _line = this.object();
	if (typeof line == 'undefined') {
		this.error('No line defined at BB.gmap.line.show()')
	}
	line.setMap(this.controller().map());
}

BB.gmap.line.prototype.hide = function()
{
	var _line = this.object();
	if (typeof line == 'undefined') {
		this.error('No line defined at BB.gmap.line.hide()')
	}
	_line.setMap(null);
}


BB.gmap.line.prototype.controller = function()
{
	return this.__CONTROLLER;
}


/**
* Require google line object
* @return this (chainable)
*/
BB.gmap.line.prototype.set_object = function( object )
{
	this.__OBJECT = object;
	return this;
}

/**
* Return google line object
* @return google.maps.Marker()
*/
BB.gmap.line.prototype.object = function()
{
	return this.__OBJECT;
}

BB.gmap.line.prototype.refresh = function()
{
	var opts = this.data('_opts');
	var line = this.object();
	line.setOptions(opts);
}

/**
* Requires either google map object
*
*/
BB.gmap.line.prototype.set_map = function( map )
{
	this.object().setMap( map );

	return this;
}

/**
 * @name BB Gmap Line
 * @version version 1.0
 * @author Bene Roch
 * @description
 * Map LINE
 * 
 */

var BB = BB || {};

BB.gmap = BB.gmap || {};

/**
* #Marker object class
* Accepts all datas at first 
* Needs a google.maps.Marker() object ( data[ 'polygon' ] ) in order
* be functionnal with all methods
*
* ##Options ( options {} )
* - `icon`:
* 	- image `url`
* 
* 
* ##Methods
*
*
*/
BB.gmap.polygon = function( data, controller )
{
	// Contains the google map object
	this.__OBJECT = undefined;
	this.__STYLES;
	this.__PATHS;
	this.__CONTROLLER = controller;

	// Set data
	this.set_data( data );

	// If case sanitize is needed in the "set_data" process,
	// retrive them with data()
	var _data = this.data();

	this.init();
	// Chainable
	return this;
}

BB.gmap.polygon.prototype = new BB.base();

BB.gmap.polygon.prototype.init = function()
{
	var _data = this.data();
	
	if (typeof _data[ 'styles' ] == 'object') {
		this.add_styles( _data[ 'styles' ]);
	}

	if (typeof _data[ 'paths' ] == 'object') {
		this.set_paths( _data[ 'paths' ]);
	}

	if (this.get_paths() && this.get_styles()) {
		this.display();
	}

	return this;
}

/**
* Getter & setters
*/

BB.gmap.polygon.prototype.add_styles = function( styles )
{
	// Add validation here.

	this.__STYLES = styles;
}

/**
* AUTOMATICALLY SETS THE STYLE
*/
BB.gmap.polygon.prototype.set_styles = function( styles )
{
	this.add_styles(styles);
	this.display();
	return this;
}

BB.gmap.polygon.prototype.get_styles = function() 
{
	return this.__STYLES;
}


BB.gmap.polygon.prototype.set_paths = function( paths )
{
	if (typeof paths != 'object') {
		this.error('Invalid paths at BB.gmap.polygon.set_paths :'+paths);
		return ;
	}

	if (!(paths[0] instanceof google.maps.LatLng)) {
		var i = 0;
		var count = paths.length;
		var coords = [];
		for (; i<count; i++) {
			if (typeof paths[i] != 'object') {
				// Error.
				break;
			}
			var push = this.controller().translate_coords(paths[i]);

			coords.push( push );
		}

		paths = coords;
	}

	this.__PATHS = paths;
}

BB.gmap.polygon.prototype.get_paths = function()
{

	return this.__PATHS;
}


BB.gmap.polygon.prototype.display = function()
{
	var _data = this.data();

	var styles = this.get_styles();
	if (typeof styles == 'undefined') {
		this.error('Undefined styles at BB.gmap.polygon.display : ' + styles)
	}

	var paths = this.get_paths();
	if (typeof paths == 'undefined') {
		this.error('Undefined paths at BB.gmap.polygon.display : ' + paths);
	}

	styles.paths = paths;

	if (typeof this.object() != 'undefined') {
		this.object().setOptions(styles);
	} else {
		var polygon = new google.maps.Polygon(styles);
		this.set_object( polygon );
	}

	this.set_map(this.controller().map());

	return this;
}

BB.gmap.polygon.prototype.show = function()
{
	var _polygon = this.object();
	if (typeof polygon == 'undefined') {
		this.error('No polygon defined at BB.gmap.polygon.show()')
	}
	polygon.setMap(this.controller().map());
}

BB.gmap.polygon.prototype.hide = function()
{
	var _polygon = this.object();
	if (typeof polygon == 'undefined') {
		this.error('No polygon defined at BB.gmap.polygon.hide()')
	}
	_polygon.setMap(null);
}


BB.gmap.polygon.prototype.controller = function()
{
	return this.__CONTROLLER;
}


/**
* Require google polygon object
* @return this (chainable)
*/
BB.gmap.polygon.prototype.set_object = function( object )
{
	this.__OBJECT = object;
	return this;
}

/**
* Return google polygon object
* @return google.maps.Marker()
*/
BB.gmap.polygon.prototype.object = function()
{
	return this.__OBJECT;
}

BB.gmap.polygon.prototype.refresh = function()
{
	var opts = this.data('_opts');
	var polygon = this.object();
	polygon.setOptions(opts);
}

/**
* Requires either google map object
*
*/
BB.gmap.polygon.prototype.set_map = function( map )
{
	this.object().setMap( map );

	return this;
}
