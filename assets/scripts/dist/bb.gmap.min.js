/**
 * @name Bene Bundle (BB)
 * @version version 1.0
 * @author Bene Roch
 * @description
 * BASE
 * All reusable object methods and properties
 * - set_data
 * - data
 * - remove_data
 * - sanitize
 * - unsanitize
 * - escape_data
 * - unescape_data
 * - ident
 * - set_ident
 * - error // using the this.__BB_DEBUG__ to output error
 * Development feature.
 */

var BB = BB || {};

/**
* BB.base Class
* Base of all BB's objects
*
*/
BB.base = function()
{

	this.__BB_DEBUG__	 = false;
	this.__PROTECTED__   = [];

	this._data = undefined;
};

/**
*
* @param data 	|	{Object}	|	{ key : data, key : data } object
* @return this (chainable)
*/
BB.base.prototype.set_data = function(data)
{
	if (typeof this._data == 'undefined') {
		this._data = new BB.data();
	}
	if (typeof data != 'object') {
		return this;
	}

	this._data.set_data(data);
	return this;

};

/**
*
* @param data 	|	{Object}	|	{ key : data, key : data } object
* @return this (chainable)
*/
BB.base.prototype.remove_data = function(data)
{
	this._data.remove_data(data);
	return this;

};

/**
*
* @return {mixed} data | {Object} data  || {Mixed} data[ key ]
*/
BB.base.prototype.get_data = function(key)
{
	var data = this.data();
	if (typeof data[ key ] != 'undefined') {
		return data[ key ];
	}
	return false;
};

/**
*
* @param data 	|	{Object}	|	{ key : data, key : data } object
* @return this (chainable)
*/
BB.base.prototype.data = function(data)
{
	return this._data.get_data(data);
};

BB.base.prototype.sanitize = function()
{
	var data = this.data();
	data = this._escape_data(data);
	this.set_data(data);
	return this;
};

/**
* Every data passed to this function will be cleaned and encoded for web
* Recursive
* Prevents output errors
* @param data 		|		{Object} 		|
* @return {Object} data
*/
BB.base.prototype._escape_data = function(data) {
	var that = this;

	if (typeof data == 'undefined') {
		return '';
	}

	if (typeof data == 'object' && data.length) {
		var i = 0;
		var count = data.length;
		for (; i < count; i++) {
			data[i] = this._escape_data(data[i]);
		}
	}

	if (typeof data == 'object') {
		for (var k in data) {
			data[k] = this._escape_data(data[k]);
		}
	}

	if (typeof data == 'string') {
		return escape( data );
	}

	// Default;
	return data;
};

/**
* Every data passed to this function will be cleaned and encoded for web
* Recursive
* Prevents output errors
* @param data 		|		{Object} 		|
* @return {Object} data
*/
BB.base.prototype._unescape_data = function(data) {
	var that = this;

	if (typeof data == 'undefined') {
		return '';
	}

	if (typeof data == 'array') {
		var i = 0;
		var count = data.length;
		for (; i < count; i++) {
			data[i] = this._unescape_data(data[i]);
		}
	}

	if (typeof data == 'object') {
		for (var k in data) {
			data[k] = this._unescape_data(data[k]);
		}
	}

	if (typeof data == 'string') {
		return unescape( data );
	}

	// Default;
	return data;
};



/**
* Return current object ident
* Ident
* @return string
*/
BB.base.prototype.ident = function()
{
	var _data = this.data();
	if (typeof _data.ident != 'string') {
		this.error('Ident is not a String which is odd. ' + _data.ident);
		return '';
	}
	return _data.ident;
};

/**
* Sets the ident for the current object
* Ident parameters must be a string. If its not, it is converted
* to one, which my give {Object object} if object values are passed.
* If __BB_DEBUG__ is on, throws an error
*
* @param string 	ident 			MUST be a string
* @return this (chainable)
*/
BB.base.prototype.set_ident = function( ident )
{
	if (typeof ident != 'string') {
		ident = ''+ident;
		this.error('Ident must be a string. Automatically converted to : ' + ident);
	}
	this.set_data({ 'ident': ident });

	return this;
};


BB.base.prototype.error = function( error_msg )
{
	if (this.__BB_DEBUG__) {
		throw Error( error_msg );
	}
	return this;
};

/**
* Utils
* Check if object is empty
* @param obj Object
* @return boolean
*/
BB.base.prototype.is_empty_object = function( obj )
{
	if (typeof obj != 'object') {
		this.error('Invalid argument, Object expected at BB.base.is_empty_object()');
		return true;
	}
	for(var prop in obj) {
		if(obj.hasOwnProperty(prop)) {
			return false;
		}
	}

	return true;
}

/**
 * Merge defaults with user options
 * @private
 * @param {Object} defaults Default settings
 * @param {Object} options User options
 * @returns {Object} Merged values of defaults and options
 */
BB.base.prototype.extend = function ( defaults, options ) {
    var extended = {};
    var prop;
    for (prop in defaults) {
        if (Object.prototype.hasOwnProperty.call(defaults, prop)) {
            extended[prop] = defaults[prop];
        }
    }
    for (prop in options) {
        if (Object.prototype.hasOwnProperty.call(options, prop)) {
            extended[prop] = options[prop];
        }
    }
    return extended;
};
/**
 * @name Bene Bundle (BB)
 * @version version 1.0
 * @author Bene Roch
 * @description
 * DATAS
 * All datas added to the object will be affected to a "data object"
 * which makes all affectation pass by a single entry point
 */

var BB = BB || {};

/**
* BB.data Class
* This class exists to decide wheiter or not you wanna
* show the data, make them accessible to the public
*
*/
BB.data = function(data)
{

	this.__PROTECTED__     = [];
	this.__HIDDEN_DATA__   = true;


	if (this.__HIDDEN_DATA__) {
		var __DATA = data || {};
		return {
			set_data: function(data) 
			{ 	
				for (var key in data) {
					__DATA[key] = data[ key ];
				}
		 	},
			get_data: function(data) 
			{ 
				if (!data) {
					return __DATA; 
				}
				if (typeof __DATA[ data ] != 'undefined') {
					return __DATA[ data ];
				}
				return '';
			},
			remove_data: function(key)
			{
				if (!key) {
					__DATA = {};
				}

				if (typeof __DATA[ key ] != 'undefined') {
					__DATA[ key ] = undefined;
					delete __DATA[ key ];
				}
				return ;
			}
		}
	}

	this.__DATA = data || {};

	this.set_data = function(data) 
	{ 
		if (!this.__DATA) {
			this.__DATA = data || {};
			return ;
		}	
		if (!data) {
			return ;
		}
		for (var key in data) {
			this.__DATA[key] = data[ key ];
		}
		return ;
	}

	this.get_data = function(data) 
	{ 
		if (!data) {
			return this.__DATA; 
		}
		if (typeof this.__DATA[ data ] != 'undefined') {
			return this.__DATA[ data ];
		}
		return ;
	}

	this.remove_data = function(key)
	{
		if (!key) {
			this.__DATA = {};
		}

		if (typeof this.__DATA[ key ] != 'undefined') {
			this.__DATA[ key ] = undefined;
			delete this.__DATA[ key ];
		}
		return ;
	}

	return this;
}


/**
 * @name BB Gmap controller
 * @version version 1.0
 * @author Bene Roch
 * @description
 * MAP Controller
 * Controller for a google map object
 * This makes it possible to track all whats going on
 * with the google map
 */

/**
* EAMPLE DATAS
*
	var map = new BB.gmap.controller(document.getElementById('test'), {
	   map: {
	   center: {
					x 	: 45.577997,
					y 	: -73.76850009999998
				},
				zoom: 15,
				mapType 	: 'roadmap',
				coordsType	: 'inpage', // array, json? (vs ul li)
				map_mode	: 'default'
		},
		places :{
			test : {
				type : 'marker',
	            icon : 'http://2.bp.blogspot.com/_--4sDAhQ5LI/TOquH6OPLWI/AAAAAAAACeM/JvG-MItGlmk/s1600/CRM5FormScripting4.png',
				coords : [ 45.577997,-73.76850009999998 ]
			}
		}
	})
	map.init()

	map.add_place_by_address('test_un_autre', '1859 iberville, montrÃ©al, qc, h2k3c4', {
		type : 'marker',
	    icon : 'http://localhost/test/assets/images/marker.png'
	})
*/
var BB = BB || {};

BB.gmap = BB.gmap || {};
/**
* This is the gmap object
*/
BB.gmap.controller = function(container, data)
{
	// Keep the map in sight
	this._MAP;

	// DOM Element where is applied the actual map
	this.__CONTAINER = container;

	// Editable makes the controller listen for events
	// such as click, mouseover, etc and dispatch that
	// event to every children in 'places'
	this.__EDITABLE = false;

	// obsolete ?
	this._MARKERS = {};

	// all places are stucked there
	// this allows a quick research by ident
	this.__PLACES = {
		markers : {},
		polygons 	: {},
		lines 	: {}
	};

	// Focused item
	// could be line, marker, polygon, polygon vertex, whatever.
	this.__FOCUSED_ITEM;

	this.set_data(data);

	return this;
}

BB.gmap.controller.prototype = new BB.base();

/**
* Return associated map
*/
BB.gmap.controller.prototype.map = function()
{
	if (!this._MAP) {
		// No map yet
		this.error('No map associated to the current controller at BB.gmap.controller.map()')
		return;
	}
	return this._MAP;
}

/**
* Helper
* Kind of does same thing but on the map object
* You can always object.map().[methods]()
* @see https://developers.google.com/maps/documentation/javascript/reference#Map
*/
BB.gmap.controller.prototype.set_zoom = function(zoom)
{
	this.map().setZoom( zoom );
}
BB.gmap.controller.prototype.container = function()
{

	return this.__CONTAINER;
}

/**
* MAP OPTIONS
* Map options will be passed AS IS to the map object
* Only the center position will be translated into google object
* center :
* {
*	x : float
*	y : float
* }
* @see https://developers.google.com/maps/documentation/javascript/reference#MapOptions
*/
BB.gmap.controller.prototype.init = function()
{
	var _data = this.data();

	// Map options
	var map_options = this.data('map');

	// Converts center position into google objects
	map_options.center = new google.maps.LatLng(parseFloat(map_options.center.x), parseFloat(map_options.center.y));

	// Affect new map object
	this._MAP = new google.maps.Map(this.container(), map_options);

	// Any places yet?
	if (typeof _data[ 'places' ] == 'undefined') {
		this.error('You haven\'t set any places yet')
		return this;
	}
	this.add_places( _data[ 'places' ] )
	return this;
}

BB.gmap.controller.prototype.set_styles = function ( styles ) {
	if (typeof styles != 'object') {
		this.error('Invalid type styles in BB.gmap.set_styles()' + styles)
	}

	// Create a new StyledMapType object, passing it the array of styles,
	// as well as the name to be displayed on the map type control.
	var styles = new google.maps.StyledMapType(styles,
	{name: "Custom"});

	//Associate the styled map with the MapTypeId and set it to display.
	this.map().mapTypes.set('custom', styles);
	this.map().setMapTypeId('custom');
	return this;
}


/**
* places :
* {
*	ident : { data },
*	ident : { data }
* }
*
*/
BB.gmap.controller.prototype.add_places = function( places )
{
	if (!places) {
		this.error('Invalid places specified :' + places)
		return this;
	}

	for (var p in places) {
		this.add_place( p, places[ p ] );
	}

	return this;
}

BB.gmap.controller.prototype.set_place = function( type, ident, data )
{
	if (!ident || !data) {
		this.error('Missing parameters in BB.gmap.controller.set_place( '+type+', '+ident+', '+data+')');
		return this;
	}
	if (typeof this.__PLACES[ type ] == 'undefined') {
		this.error('Invalid data type at BB.gmap.controlle.set_place( '+type+', '+ident+', '+data+')');
		return this;
	}
	if (typeof this.__PLACES[ type ][ ident ] == 'undefined') {
		this.__PLACES[ type ][ ident ] = {};
	}
	this.__PLACES[ type ][ ident ] = data;
	return this;
}

/**
* {
*	ident : { data }
* }
*
*/
BB.gmap.controller.prototype.add_place = function( ident, data )
{
	if (!data) {
		this.error('Missing parameter BB.gmap.controller.prototype.add_place ( ident, data ) : ( ' + ident + ', ' + data + ' )');
		return this;
	}

	// Every place should have is uniq ident
	if (typeof data[ 'type' ] != 'string') {
		this.error('Missing parameter "type" in BB.gmap.controller.prototype.add_place');
		return this;
	}

	// Set ident.
	data[ 'ident' ] = ident;

	var type = data['type'];


	switch (type) {
		case 'marker':
			this.set_place('markers', ident, new BB.gmap.marker(data, this));
			// Might add some extra sanitize functions here
			// this.set_place('markers', ident, data)

		break;

		case 'line' :
			this.set_place('lines', ident, new BB.gmap.line(data, this));
			// this.add_line( ident, data );
			// this.set_place('lines', ident, data)
		break;

		case 'polygon':
			this.set_place('polygons', ident, new BB.gmap.polygon(data, this));
			// this.add_polygon( ident, data );
			// this.set_place('polygons', ident, data)
		break;
	}

	return this;
}

BB.gmap.controller.prototype.get_places = function()
{
	return this.__PLACES;
}
BB.gmap.controller.prototype.get_places_by_type = function(type)
{
	return this.__PLACES[ type ];
}

/**
*
*
*/
BB.gmap.controller.prototype.add_marker = function( ident, data )
{
	this.set_place('markers', ident, new BB.gmap.marker(data, this));
	this.get_places_by_type('markers')[ ident ].set_ident('ident');
	return this;
}

/**
*
* @return {mixed} BB.gmap.marker || false
*/
BB.gmap.controller.prototype.get_marker = function( ident )
{
	var _markers = this.get_places_by_type('markers');

	if (typeof _markers[ ident ] == 'undefined') {
		this.error('Invalid marker ident at BB.gmap.controller.get_marker( ident ) : ' + ident)
		return false;
	}
	return _markers[ ident ];
}

BB.gmap.controller.prototype.add_place_by_address = function( ident, address, data )
{
	var that = this;
	this.geocode_address( address, function(coords) {
		data.coords = coords;
		that.add_place(ident, data);
	})
}


BB.gmap.controller.prototype.geocode_address = function( address, callback )
{
	var ret = Array();

	if (typeof google != 'undefined') {

		var geocoder = new google.maps.Geocoder();

		geocoder.geocode({
			'address': address
		},
		function(results, status) {

		  if (status == google.maps.GeocoderStatus.OK) {
			var lat = results[0].geometry.location.lat();
			var lon = results[0].geometry.location.lng();

			if (typeof callback == 'function') {
				callback( [lat, lon ] );
			}

		  }
		  return ret;

		});

	} else {

		return error;

	}
}

/**
*
* @return {mixed} BB.gmap.marker || false
*/
BB.gmap.controller.prototype.get_place = function( ident )
{
	var places = this.get_places();
	var place = false;

	for (var k in places)
	{
		var places_by_type = this.get_places_by_type( k );

		if (!this.is_empty_object( places_by_type )) {
			place = typeof places_by_type[ ident ] == 'object' ? places_by_type[ ident ] : place;
		}
	}

	if (!place) {
		this.error('Invalid ident at BB.gmap.controller.get_place( ident ) : ' + ident);
		return false;
	}

	return place;
}

/**
*
*
*/
BB.gmap.controller.prototype.set_focus = function( item )
{
	var _data = item.data();

	var type = _data[ 'type' ];

	this.__FOCUSED_ITEM = item;
}

/**
* Retrieve focus Item, then change it.
*/
BB.gmap.controller.prototype.focused = function()
{
	return this.__FOCUSED_ITEM;
}

BB.gmap.controller.prototype.add_clusterer = function()
{

}
BB.gmap.controller.prototype.get_clusterer = function()
{

}

BB.gmap.controller.prototype.filter = function( filters )
{

}

BB.gmap.controller.prototype.clear_infoboxes = function()
{

}

BB.gmap.controller.prototype.refresh = function()
{
	this.clear_infoboxes();

}

/**
* Utils
* @param Array [ lat, lon ]
*/
BB.gmap.controller.prototype.translate_coords = function(coords) {
	if (typeof coords != 'object') {
		return ;
	}

	var total = coords.length;
	if (total != 2) {
		return ;
	}
	return new google.maps.LatLng(coords[0], coords[1]);
}


BB.gmap.controller.prototype.set_editable = function(param)
{
	if (!param) {

		var places = this.get_places();
		var has_editable = false;

		this._loop_all(function( place ) {
			var _data = place.data();
			if (_data['editable']) {
				has_editable = true;
			}
		});

		if (!has_editable) {
			this.__EDITABLE = false;
			google.maps.event.clearListeners(this.map(), 'click');
		}

		return this;
	}

	// No need for more event listeners
	if (this.__EDITABLE) {
		return this;
	}

	this.__EDITABLE = true;
	var that = this;
	google.maps.event.addListener(this.map(), 'click', function(event) { that.map_click(event) });

}

/**
* Listeners for map click
* This is where everything happen to have a single click event on the map
* @param event google map event
* @return this (chainable)
*/
BB.gmap.controller.prototype.map_click = function(event)
{
	// Just in case
	if (!this.__EDITABLE) {
		google.maps.event.clearListeners(this.map(), 'click');
		return false;
	}

	this._loop_all(function(place) {
		var _data = place.data();
		if (_data['editable']) {
			place.map_click( event );
		}
	})

	return this;

}



/**
* Since I manually looped all markers and points, I
* made that function to do just that.
* @param callback function Will receive a place as argument
* @return this (chainable)
**/
BB.gmap.controller.prototype._loop_all = function( callback )
{
	if (typeof callback != 'function') {
		return this;
	}

	var places = this.get_places();
	for (var k in places)
	{
		var places_by_type = this.get_places_by_type( k );

		if (!this.is_empty_object( places_by_type )) {
			for (var ident in places_by_type) {

				callback( places_by_type[ ident ] );

			}
		}
	}

	return this;
}
/**
 * @name BB Gmap Line
 * @version version 1.0
 * @author Bene Roch
 * @description
 * Map LINE
 *
 */

var BB = BB || {};

BB.gmap = BB.gmap || {};

/**
* #Line object class
* Accepts all datas at first
* Needs a google.maps.Polyline() object ( data[ 'line' ] ) in order
* be functionnal with all methods
*
* ##Options ( data )
*
* - type ( line // polygon )
*
* - styles
* 	- strokeColor
* 	- strokeOpacity
* 	- strokeWeight
* 	- fillColor
* 	- fillOpacity
*
* - editable (makes map drawable)
*
* ##Methods
*
*
*/
BB.gmap.line = function( data, controller )
{
	// Contains the google map object
	this.__OBJECT = undefined;
	this.__STYLES;
	this.__PATHS;

	// One marker per point to make it editable
	this.__MARKERS;

	this.__CONTROLLER = controller;

	this.__MARKERS = {};

	// Set data
	this.set_data( data );

	// If case sanitize is needed in the "set_data" process,
	// retrive them with data()
	var _data = this.data();

	this.init();
	// Chainable
	return this;
}

BB.gmap.line.prototype = new BB.base();

/**
*
*/
BB.gmap.line.prototype.init = function()
{
	var _data = this.data();

	// Set styles
	if (typeof _data[ 'styles' ] == 'object') {
		this.add_styles( _data[ 'styles' ]);
	}

	// Default = Empty array
	// Makes it possible to DRAW a new line or polygon
	this.set_paths( [] );

	// Set paths
	if (typeof _data[ 'paths' ] == 'object') {
		var i = 0;
		var total = _data[ 'paths' ].length;
		for (; i<total; i++) {
			this.add_point( _data[ 'paths' ][ i ] );
		}
	}


	if (this.get_paths() && this.get_styles()) {
		this.display();
	}

	// Allow editable from options
	if (_data[ 'editable' ]) {
		this.set_editable( _data['editable'] );
	}

	return this;
}

/**
* Pretty much the same as init, but removing all markers associated
* and all listeners to get a fresh start.
*
*/
BB.gmap.line.prototype.redraw = function()
{
	// Scope
	var that = this;

	// Paths
	var paths = this.get_paths();
	var i = 0;
	var total = paths.length;

	var new_paths = [];

	for (; i<total; i++) {
		new_paths.push([ paths.getAt( i ).lat(), paths.getAt( i ).lng() ]);

		if (typeof this.__MARKERS[ i ] != 'undefined') {
			this.__MARKERS[ i ].hide();
		}
	}

	this.set_data({ paths : new_paths });
	this.init();
}



/**
* Getter & setters
*/

BB.gmap.line.prototype.add_styles = function( styles )
{
	// Add validation here.

	this.__STYLES = styles;
}

/**
* AUTOMATICALLY SETS THE STYLE
*/
BB.gmap.line.prototype.set_styles = function( styles )
{
	this.add_styles(styles);
	this.display();
	return this;
}

BB.gmap.line.prototype.get_styles = function()
{
	return this.__STYLES;
}


BB.gmap.line.prototype.set_paths = function( paths )
{
	if (typeof paths != 'object') {
		this.error('Invalid paths at BB.gmap.line.set_paths :'+paths);
		return ;
	}

	if (!(paths[0] instanceof google.maps.LatLng)) {
		var i = 0;
		var count = paths.length;
		var coords = new google.maps.MVCArray;
		for (; i<count; i++) {
			if (typeof paths[i] != 'object') {
				// Error.
				break;
			}
			var push = this.controller().translate_coords(paths[i]);

			coords.insertAt( coords.length, push );
		}
		paths = coords;
	}
	this.__PATHS = paths;
}

/**
* Return paths
* @return coord MVCArray paths
*/
BB.gmap.line.prototype.get_paths = function()
{
	return this.__PATHS;
}

BB.gmap.line.prototype.display = function()
{
	var _data = this.data();

	var styles = this.get_styles();
	if (typeof styles == 'undefined') {
		this.error('Undefined styles at BB.gmap.line.display : ' + styles)
	}

	var paths = this.get_paths();

	if (typeof paths == 'undefined') {
		this.error('Undefined paths at BB.gmap.line.display : ' + paths);
	}

	styles.path = paths;

	if (typeof this.object() != 'undefined') {
		this.object().setOptions(styles);
	} else {
		var line = new google.maps.Polyline(styles);
		this.set_object( line );
	}

	this.set_map(this.controller().map());

	return this;
}

BB.gmap.line.prototype.show = function()
{
	var _line = this.object();
	if (typeof line == 'undefined') {
		this.error('No line defined at BB.gmap.line.show()')
	}
	line.setMap(this.controller().map());
}

BB.gmap.line.prototype.hide = function()
{
	var _line = this.object();
	if (typeof line == 'undefined') {
		this.error('No line defined at BB.gmap.line.hide()')
	}
	_line.setMap(null);
}


BB.gmap.line.prototype.controller = function()
{
	return this.__CONTROLLER;
}


/**
* Require google line object
* @return this (chainable)
*/
BB.gmap.line.prototype.set_object = function( object )
{
	this.__OBJECT = object;
	return this;
}

/**
* Return google line object
* @return google.maps.Marker()
*/
BB.gmap.line.prototype.object = function()
{
	return this.__OBJECT;
}

BB.gmap.line.prototype.refresh = function()
{
	var opts = this.data('_opts');
	var line = this.object();
	line.setOptions(opts);
}

/**
* Requires either google map object
*
*/
BB.gmap.line.prototype.set_map = function( map )
{
	this.object().setMap( map );

	return this;
}

/**
* @param path Coords or the point
*/
BB.gmap.line.prototype.add_point = function(path, index)
{
	// Not good
	if (typeof path != 'object') {
		return false;
	}
	// Not good.
	if ( !(path instanceof google.maps.LatLng) ) {
		path = this.controller().translate_coords(path);
	}
	if ( (!(path instanceof google.maps.LatLng)) && (typeof path[ 0 ] == 'undefined' || typeof path[ 1 ] == 'undefined')) {
		// Something missing
		return false;
	}
	// Scope
	var that = this;


	var paths = this.get_paths();

	// Allows to have empty path polygon
	// Allows to CREATE a new polygon
	if (typeof paths == 'undefined') {
		this.set_paths( [ [ path.lat(), path.lng() ] ] );
	}
	paths = this.get_paths();


	if (typeof index != 'number') {
		index = paths.length;
	}

	paths.insertAt(index, path);


	// Add marker on top of it
	var marker = new BB.gmap.marker({
		coords : [ path.lat(), path.lng() ],
		draggable: true,
		ondragend : function(event) {
			that.move_point( this.index, [ event.latLng.lat(), event.latLng.lng() ] );
		},
		index: index
	}, that.controller());

	if (!this.__MARKERS) {
		this.__MARKERS = [];
	}
	this.__MARKERS[ index ] = marker;

	return this;
}

/**
* When dragging a marker to change the point
* or whatever concerning the moving of a single point on
* a polygon
*
* @param {Integer} index Index of the 'point'
* @param {Object} path Coordinates of the new emplacement
* @return this || false
*/
BB.gmap.line.prototype.move_point = function( index, path )
{
	console.log(index, 'move point index');
	var paths = this.get_paths();
	if (typeof paths != 'object') {
		// How can you move something inexistant?
		this.error('You can not move a point when no path is given at BB.gmap.line.move_point( index, path )');
		return false;
	}
	if (!path) {
		this.error('Required arguments index:integer and path:object at BB.gmap.line.move_point( index, path )');
		return false;
	}

	// Not good.
	if ( !(path instanceof google.maps.LatLng) ) {
		path = this.controller().translate_coords(path);
	}
	if ( (!(path instanceof google.maps.LatLng)) && (typeof path[ 0 ] == 'undefined' || typeof path[ 1 ] == 'undefined')) {
		// Something missing
		return false;
	}
	// Scope
	var that = this;

	paths.setAt( index, path );

	return this;
}

/**
* Remove one point from the polygon
* @param {Integer} Index
* @return this (chainable)
*/
BB.gmap.line.prototype.remove_point = function( index )
{
	var paths = this.get_paths();
	if (typeof paths != 'object') {
		// How can you move something inexistant?
		this.error('You can not move a point when no path is given at BB.gmap.line.move_point( index, path )');
		return false;
	}

	// Remove that paths.
	paths.removeAt( index );

	if (typeof this.__MARKERS[ index ] != 'undefined') {
		this.__MARKERS[ index ].hide();
		this.__MARKERS.splice( index, 1 );
	}

	var _m = this.__MARKERS;
	for (var i in _m) {
		_m[ i ].marker().index = parseInt( i );
	}

	this.redraw();

	return this;
}


/**
* @param boolean
*/
BB.gmap.line.prototype.set_editable = function(param)
{
	if (!param) {
		this.set_data({ 'editable' : false });
		this.controller().set_editable(false);
		return this;
	}



	// Add listeners and stuff
	this.set_data({ 'editable' : true });

	this.controller().set_editable(true);

	return this;

}

BB.gmap.line.prototype.map_click = function(event)
{
	this.add_point(event.latLng);
}


/**
* Enables or disable draggable
* @return this (chainable)
*/
BB.gmap.line.prototype.set_draggable = function(bool)
{
	var styles = this.get_styles();

	if (!bool) {
		styles.draggable = false;
	} else {
		styles.draggable = true;
	}

	this.set_styles(styles);
	return this;

}

/**
 * @name BB Gmap controller
 * @version version 1.0
 * @author Bene Roch
 * @description
 * MAP Controller
 * Controller for a google map object
 * This makes it possible to track all whats going on
 * with the google map
 */

var BB = BB || {};

BB.gmap = BB.gmap || {};

/**
* #Marker object class
* Accepts all datas at first
* Needs a google.maps.Marker() object ( data[ 'marker' ] ) in order
* be functionnal with all methods
*
* ##Options ( options {} )
* - `icon`:
* 	- image `url`
*
*
* ##Methods
*
*
*/
BB.gmap.marker = function( data, controller )
{
	// Contains the google map object
	this.__MARKER = undefined;
	this.__MEDIA;
	this.__CONTROLLER = controller;

	// Status vars
	this._image_loaded = false;
	this._marker_loaded = false;

	// Set data
	this.set_data( data );

	// If case sanitize is needed in the "set_data" process,
	// retrive them with data()
	var _data = this.data();

	this.init();
	// Chainable
	return this;
}

/**
*
*/
BB.gmap.marker.prototype = new BB.base();

/**
*
*/
BB.gmap.marker.prototype.init = function()
{
	var _data = this.data();


	if (typeof _data['icon'] == 'string') {
		// No display called afterward
		// @see set_image() -> display() called after the image load.
		this.set_image( _data.icon );
	} else {
		// No image load, no need to wait.
		this.display();
	}

	this.__ICON;

	return this;
}

/**
*
*/
BB.gmap.marker.prototype.icon = function()
{
	if (!this.__ICON) {
		this.error('No icon were defined yet.')
		return new Image();
	}
	return this.__ICON;
}

/**
* Sets the icon for the marker
* Each marker can have a different icon
* @return this (chainable)
*/
BB.gmap.marker.prototype.set_icon = function( icon )
{
	if (typeof icon != 'object') {
		this.error('Invalid icon at BB.gmap.marker.prototype.set_icon( ' + icon + ' )');
		return this;
	}
	this.__ICON = icon;

	return this;
}

/**
* Sets the image for the icon, preloads it
* Calls the this.set_icon() function after loading
* @return this (chainable)
*/
BB.gmap.marker.prototype.set_image = function( src )
{
	var img = new Image();

	img.data = this;

	img.onload = function()
	{
		this.data.set_icon( this );
		this.data.display();
	}

	img.onerror = function()
	{
		// Icon didn't work, treat it as if there's just no icon
		this.data.set_data({ 'icon' : undefined });
		this.data.display();
	}
	img.src = src;

	return this;
}

/**
*
*
*/
BB.gmap.marker.prototype.display = function()
{
	// if ()
	var width = this.icon().width;
	var height = this.icon().height;

	var _data = this.data();

	if (typeof _data.coords != 'object') {
		this.error('Requires coordinates [lat, lng] at BB.gmap.marker.display()');
		return false;
	}
	var options = {
		map: this.controller().map(),
	   	position: new google.maps.LatLng(_data.coords[0], _data.coords[1]),
	   	optimized: false
	}

	options = this.extend(options, _data);

	if (this.icon().src) {
		options.icon =  new google.maps.MarkerImage(
			// image src
			this.icon().src,
			// Width, Height.
			new google.maps.Size(width, height),
			// Origin for this image; X, Y.
			new google.maps.Point(0, 0),
			// Anchor for this image; X, Y.
			new google.maps.Point(width, height),
			new google.maps.Size(width, height)
	   	)
	}

	// Mini extend
	var custom_options = ( typeof _data['options'] == 'object' ) ? _data[ 'options' ] : {};
	for (var k in custom_options) {
		options[ k ] = custom_options[ k ];
	}

	if (typeof this.marker() != 'undefined') {
		this.marker().setOptions(options);
	} else {
		var marker = new google.maps.Marker(options);
		this.set_marker( marker );
	}

	this.listeners();

	return this;
}

/**
* show the marker
* @return this (chainable)
*/
BB.gmap.marker.prototype.show = function()
{
	var _marker = this.marker();
	if (typeof marker == 'undefined') {
		this.error('No marker defined at BB.gmap.marker.show()')
	}
	marker.setMap(this.controller().map());

	return this;
}

/**
* Hide the marker
* @return this (chainable)
*/
BB.gmap.marker.prototype.hide = function()
{
	var _marker = this.marker();
	if (typeof marker == 'undefined') {
		this.error('No marker defined at BB.gmap.marker.hide()')
	}
	_marker.setMap(null);

	return this;
}

/**
* @return BB.gmap.controller
*/
BB.gmap.marker.prototype.controller = function()
{
	return this.__CONTROLLER;
}


/**
* Require google marker object
* @return this (chainable)
*/
BB.gmap.marker.prototype.set_marker = function( marker )
{
	if (this._marker_loaded) {
		// Error
		this.error( 'There is already a marker affected to this instanciation of a [BB.gmap.marker] ( ' + this.ident() + ' )' );
		return this;
	}
	this._marker_loaded = true;

	this.__MARKER = marker;
	return this;
}

/**
* Return google marker object
* @return google.maps.Marker()
*/
BB.gmap.marker.prototype.marker = function()
{
	return this.__MARKER;
}

/**
* Requires either google map object
*
*/
BB.gmap.marker.prototype.set_map = function( map )
{
	this.marker().setMap( map );

	return this;
}

/**
* Sets or remove listeners according to plan and / but mainly options.
*
*/
BB.gmap.marker.prototype.listeners = function()
{
	// Scope
	var that = this;

	// Marker
	var marker = this.marker();

	marker.bbmarker = this;

	if (this.data( 'draggable' )) {
		google.maps.event.addListener(marker, 'dragend', that.dragend);
	}

	// click listeners
	// No condition, which is different to the dragend option
	// We might always use the click event, I see no reason to make
	// it optional. Options will occur in the event handler.
	google.maps.event.addListener(marker, 'click', that.onclick);


}

/**
* Event handler
* Dragend event handler. Calls the callback if it exists
*
* this = marker object
* @param {Event} event
*/
BB.gmap.marker.prototype.dragend = function(event)
{
	// Scope
	var that = this.bbmarker;

	var _data = that.data();

	if (typeof _data[ 'ondragend' ] == 'function') {
		_data.ondragend( event );
	}

}

/**
* Event handler
* Click event handler. Calls the callback if it exists
* Used to store the index of the current marker
*
* this = marker object
* @param {Event} event
*/
BB.gmap.marker.prototype.onclick = function(event)
{
	// Scope
	var that = this.bbmarker;

	var _data = that.data();


	if (typeof _data[ 'onclick' ] == 'function') {
		_data.onclick( event );
	}

	that.focus();

}

/**
*
*marker-selected.png
*/
BB.gmap.marker.prototype.focus = function()
{
	// Scope
	var that = this;

	// Data
	var _data = this.data();

	var focused = that.controller().focused();

	if (focused) {
		focused.blur();
	}

	// Selected icon
	if (_data[ 'icon_selected' ]) {
		this.set_image( _data[ 'icon_selected' ] );
	}

	that.controller().set_focus( that );

}

BB.gmap.marker.prototype.blur = function()
{
	// Scope
	var that = this;

	// Data
	var _data = this.data();

	// Selected icon
	if (_data[ 'icon_selected' ]) {
		// No need to put back the icon if there's not selected icon specified.
		this.set_image( _data[ 'icon' ] );
	}
}



/**
* @remove ?
*/
// BB.gmap.marker.prototype.refresh = function()
// {
// 	var opts = this.data('_opts');
// 	var marker = this.marker();
// 	marker.setOptions(opts);
// }
/**
 * @name BB Gmap Line
 * @version version 1.0
 * @author Bene Roch
 * @description
 * Map LINE
 * 
 */

var BB = BB || {};

BB.gmap = BB.gmap || {};

/**
* #Marker object class
* Accepts all datas at first 
* Needs a google.maps.Marker() object ( data[ 'line' ] ) in order
* be functionnal with all methods
*
* ##Options ( options {} )
* - `icon`:
* 	- image `url`
* 
* 
* ##Methods
*
*
*/
BB.gmap.obj = function( data, controller )
{
	// Last state of the map
	// In case of ctrl+Z
	this.__LAST_STATE;
}

BB.gmap.obj.prototype.change = function(event)
{
	this.__LAST_STATE = this;
}

BB.gmap.obj.prototype._init = function()
{
	if (document.addEventListener) { // For all major browsers, except IE 8 and earlier
		document.addEventListener("click", myFunction);
	} else if (document.attachEvent) { // For IE 8 and earlier versions
		document.attachEvent("onclick", myFunction);
	}
}

/**
 * @name BB Gmap Line
 * @version version 1.0
 * @author Bene Roch
 * @description
 * Map LINE
 * 
 */

var BB = BB || {};

BB.gmap = BB.gmap || {};

/**
* #Marker object class
* Accepts all datas at first 
* Needs a google.maps.Marker() object ( data[ 'polygon' ] ) in order
* be functionnal with all methods
*
* ##Options ( options {} )
* - `icon`:
* 	- image `url`
* 
* 
* ##Methods
*
*
*/

BB.gmap.polygon = function( data, controller )
{
	// Contains the google map object
	this.__OBJECT = undefined;
	this.__STYLES;
	this.__PATHS;
	this.__CONTROLLER = controller;

	// Set data
	this.set_data( data );

	// If case sanitize is needed in the "set_data" process,
	// retrive them with data()
	var _data = this.data();

	this.init();
	// Chainable
	return this;
}

/**
* Extends BB.gmap.line
*/
BB.gmap.polygon.prototype = Object.create(BB.gmap.line.prototype);

/**
* Only difference
*/
BB.gmap.polygon.prototype.display = function()
{
	var _data = this.data();

	var styles = this.get_styles();
	if (typeof styles == 'undefined') {
		this.error('Undefined styles at BB.gmap.polygon.display : ' + styles)
	}

	// Setting paths
	var paths = this.get_paths();
	if (typeof paths == 'undefined') {
		this.error('Undefined paths at BB.gmap.polygon.display : ' + paths);
	}


	// styles.paths = paths;



	if (typeof this.object() != 'undefined') {
		this.object().setOptions(styles);
	} else {
		var polygon = new google.maps.Polygon(styles);
		this.set_object( polygon );
	}

	this.object().setPaths( new google.maps.MVCArray([paths]) );

	this.set_map(this.controller().map());

	return this;
}
